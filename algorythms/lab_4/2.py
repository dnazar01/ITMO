graph = {
    "Проспект Ленина": ["Улица Гагарина", "Площадь Ленина", "Парк Горького"],
    "Улица Гагарина": ["Проспект Октября"],
    "Проспект Октября": ["Улица Горького"],
    "Улица Горького": ["Улица Ленина"],
    "Улица Ленина": ["Проезд Кирова"],
    "Проезд Кирова": [],
    "Площадь Ленина": ["Площадь Революции"],
    "Площадь Революции": ["Центральный Парк"],
    "Центральный Парк": [],
    "Парк Горького": ["Улица Свердлова"],
    "Улица Свердлова": ["Метро"],
    "Метро": [],
}


def dfs(graph, start, visited=None, path=None):
    """
    Функция для обхода графа в глубину (Depth-First Search).

    Параметры:
    - graph: словарь, представляющий граф.
    - start: начальная вершина, с которой начинается обход.
    - visited: множество посещенных вершин (по умолчанию None).
    - path: список вершин, представляющий путь обхода (по умолчанию None).

    Возвращает список вершин в порядке обхода.
    """
    if visited is None:
        visited = set()  # Инициализируем множество посещенных вершин
    if path is None:
        path = []  # Инициализируем путь обхода

    visited.add(start)  # Добавляем текущую вершину в множество посещенных
    path.append(start)  # Добавляем текущую вершину в путь

    # Рекурсивно вызываем функцию для всех соседних вершин
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited, path)

    return path  # Возвращаем список вершин в порядке обхода


def bfs(graph, start):
    """
    Функция для обхода графа в ширину (Breadth-First Search).

    Параметры:
    - graph: словарь, представляющий граф.
    - start: начальная вершина, с которой начинается обход.

    Возвращает список вершин в порядке обхода.
    """
    visited = set()  # Инициализируем множество посещенных вершин
    queue = [start]  # Инициализируем очередь для обхода
    path = []  # Инициализируем путь обхода

    while queue:
        vertex = queue.pop(0)  # Извлекаем вершину из очереди
        if vertex not in visited:
            path.append(vertex)  # Добавляем вершину в путь обхода
            visited.add(vertex)  # Добавляем вершину в множество посещенных
            queue.extend(graph[vertex])  # Добавляем всех соседних вершин в очередь

    return path  # Возвращаем список вершин в порядке обхода



# Поиск кратчайшего пути в глубину
print("DFS:")
dfs_path = dfs(graph, "Проспект Ленина")
print(" -> ".join(dfs_path))

# Поиск кратчайшего пути в ширину
print("\nBFS:")
bfs_path = bfs(graph, "Проспект Ленина")
print(" -> ".join(bfs_path))
