from collections import deque


def find_exit(matrix, start):
    rows = len(matrix)
    cols = len(matrix[0])
    visited = set()  # Множество для отслеживания посещенных ячеек
    queue = deque(
        [(start[0], start[1], [])]
    )  # Очередь для BFS, каждый элемент: (строка, столбец, путь)

    while queue:
        row, col, path = (
            queue.popleft()
        )  # Получаем координаты текущей ячейки и путь до нее
        if matrix[row][col] == 0:  # Проверяем, является ли текущая ячейка проходом
            if (
                row == 0 or row == rows - 1 or col == 0 or col == cols - 1
            ):  # Если текущая ячейка находится на границе лабиринта, это выход
                return path + [(row, col)]  # Возвращаем полный путь от начала до выхода
            visited.add((row, col))  # Добавляем текущую ячейку в множество посещенных
            for dr, dc in [
                (1, 0),
                (-1, 0),
                (0, 1),
                (0, -1),
            ]:  # Перебираем соседние ячейки
                new_row, new_col = row + dr, col + dc
                # Проверяем, что новые координаты находятся в пределах лабиринта и ячейка еще не посещена
                if (
                    0 <= new_row < rows
                    and 0 <= new_col < cols
                    and (new_row, new_col) not in visited
                ):
                    # Добавляем новую ячейку в очередь с путем, который прошли
                    queue.append((new_row, new_col, path + [(row, col)]))

    return None  # Если выхода не найдено, возвращаем None


# Пример матрицы
a = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1],
    [1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1],
    [1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1],
    [1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1],
    [0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0],
    [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1],
    [1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
    [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
]

# Найти выход из лабиринта, начиная с (text_file.txt, text_file.txt)
exit_path = find_exit(a, (1, 1))

if exit_path:
    print("Путь к выходу:")
    for row, col in exit_path:
        print(f"({row}, {col})", end=" -> ")
    print("Выход")
else:
    print("Выхода из лабиринта нет.")
