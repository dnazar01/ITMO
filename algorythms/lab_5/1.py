def knapsack(items, weight_limit):
    # Создаем матрицу для хранения максимальной стоимости украденных предметов
    # dp[i][j] будет хранить максимальную стоимость предметов, которые можно унести
    # при ограничении веса j и доступных предметах от 0 до i
    dp = [[0 for _ in range(weight_limit + 1)] for _ in range(len(items) + 1)]

    for i in range(1, len(items) + 1):
        for j in range(1, weight_limit + 1):
            # Если вес текущего предмета меньше или равен текущему ограничению веса,
            # мы можем попробовать добавить его к нашей сумме украденных предметов
            if items[i - 1][0] <= j:
                dp[i][j] = max(
                    dp[i - 1][j], dp[i - 1][j - items[i - 1][0]] + items[i - 1][1]
                )
            else:
                # Если вес текущего предмета больше текущего ограничения веса,
                # мы не можем его взять, поэтому просто копируем значение из предыдущей строки
                dp[i][j] = dp[i - 1][j]

    # Теперь нужно восстановить украденные предметы
    stolen_items = []
    i, j = len(items), weight_limit
    while i > 0 and j > 0:
        # Если значение в текущей клетке отличается от значения в клетке выше,
        # значит мы взяли текущий предмет
        if dp[i][j] != dp[i - 1][j]:
            stolen_items.append(items[i - 1])
            j -= items[i - 1][0]
        i -= 1

    return dp[len(items)][weight_limit], stolen_items


# Пример использования
items = [(2, 3), (3, 4), (4, 5), (5, 6)]  # Каждый элемент - кортеж (вес, стоимость)
weight_limit = 5  # Максимальный вес, который может унести вор
max_value, stolen_items = knapsack(items, weight_limit)
print("Максимальная стоимость украденных предметов:", max_value)
print("Украденные предметы:", stolen_items)
